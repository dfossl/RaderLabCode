setwd("C:\\Users\\dfoss\\Documents\\Projects\\RaderLab\\RaderLabCode")
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("R_initialize_metadata.R")
source("DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
#Input Data
# Setting Working Directory
# Shows current working directory.
getwd()
# If working Directory should change place path here.
setwd(workingDirectory)
# This location is where ouput Files will Start. Should be name of folder in working directory
OutputFileDirectory <- file.path(workingDirectory, outputDirName)
# Location of data
# This is usually in the working directory but doesn't have to be.
#Keep all data in one directory and padting the specific directory here
# can be useful for not having duplicates
CountFileDirectory <- CountFileDirectory
# AnnotationFileDirectory <- "/Users/dfossl/OneDrive/Documents/Dylan_School_Cloud/Rader Lab/Analysis-LP/Deseq2Analysis_LowPhosphorous/LP_annotation.csv"
AnnotationFileDirectory <- AnnotationFileDirectory
cts <- read.csv(CountFileDirectory, row.names=1)
coldata <- read.csv(AnnotationFileDirectory, row.names=1)
coldata <- droplevels(coldata)
# WARNING: A common error is having numbers in the annotation makes those columns not be considered Factors
# You can force a column to be considered a factor with the following code.
# coldata$column <- factor(coldata$column)
#Makes sure the columns in data match rows in annotation.
checkColumnsMatch(coldata, cts)
rownames(coldata) %in% colnames(cts)
if(!checkColumnsMatch(coldata, cts)){
print("ERROR, you have rows and columns with different names or exrta rows or columns.
Therefore reformat Data till TRUE. ")
}
#expVariables holds list of variable conditions
expvariables <- colnames(coldata)
expvariables
# Set what the minimum count you wish each row to sum too.
# Deseq2 Documentation claims more robust filtering in making the Deseq object
# So I am trusting them on this,
minimumCount <- 10
# Creating DESeq2Dataset
# Must pick design, the variable you want actually contrast should be second.
# Following link provides a comprehensive description of how different designs can work.
# See: https://rstudio-pubs-static.s3.amazonaws.com/329027_593046fb6d7a427da6b2c538caf601e1.html
# I have preset work flows for different analysis for looking if there is some variable specific effect, comparing at specific timepoints, and controling for time.
#________________Time Course Analysis___________________#
#https://bioconductor.org/packages/release/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#time-course-experiments
# Preforms a likelhood ratio test where we remove the condition-specific
# differences over Time. Genes with small p values
# from this test are those which in one or more timepoints after
# 1 hour showed a condition-specific effect.
# this means genes that moved up or down in both samples over
# time will not get small p-values
# Creates a deseq object.
# design factors should be columns in the annotation file
# uncomment following lines for data with time points
#ddsTimeSeries<-DESeqDataSetFromMatrix( countData = cts,
#                             colData = coldata,
#                             design = ~ timepoint + condition + timepoint:condition)
# ddsTimeSeries <- DESeq(ddsTimeSeries, test="LRT", reduced = ~ timepoint + condition)
# Gets results with signifgant alpha being 0.01
#resTimeSeriesp.01 <- results(ddsTimeSeries, alpha = 0.01)
#resTimeSeriesp.01
#how many gense differ due to chosen variable "time"
#sum(resTimeSeriesp.01$padj < 0.01, na.rm=TRUE)
# orders most signifigant to least
#resTSOrdered <- resTimeSeriesp.01[order(resTimeSeriesp.01$padj),]
# stores the ordered data in CSV
#filename <- "TimeSeries.csv"
#write.csv(resTSOrdered, file = paste(OutputFileDirectory, "/", gsub(":", "-", gsub(" ", "_", Sys.time())), filename, sep=""))
# Goes through top 10 genes of most variation over time.
# change n to change number of genes you want to save
#filename <- "OverTime.tiff"
#n <- 1
#for(i in 1:n){
#  index = as.numeric(i)
#Note you need to have the ordered data "resTSOrdered"
#  geneName <- as.character(rownames(resTSOrdered)[index])
#  p <- countPlotOver2Variables(ddsTimeSeries, geneName, "timepoint", "condition")
#  tiff(paste(OutputFileDirectory, "/", geneName, filename, sep=""), width=12, height=12, res=300)
#  print(p)
#  dev.off()
#}
#____________________END of Time Course analysis_________________#
#____________________Analysis at specific timepoints_____________#
# If time course shows genes are variable over time (or some other variable)
# then good idea to do analysis at each time
source("NewFullRNAseqPipeline_metadata.R")
dds<-DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
# sorts using mincount set in first section
{
keep<-rowSums(DESeq2::counts(dds))>=minimumCount
dds<-dds[keep,]
}
dds <- DESeq(dds)
#_________PreProcessing___________#
counts <- DESeq2::counts(dds, normalized = TRUE)
design <- as.data.frame(colData(dds))
rld <- rlog(dds, blind=T)
colData(rld)
#PCA
# pcaData <- plotPCA(rld, intgroup=c("Groups"), returnData=TRUE)
# rader_plotPCA is the same as plotPCA but allows you to give a paraemeter "groups" That is the list of columns of count data you want to use.
# pcaData <- rader_plotPCA(rld, intgroup=c("Groups"), returnData=TRUE)
# groupsToLookAt = c("CmLS_24.1Counts","CmLS_24.2Counts", "CmLS_24.3Counts",
#                    "CmLS_1.1Counts","CmLS_1.2Counts","CmLS_1.3Counts",
#                    "RM_1h_1","RM_1h_2","RM_1h_3",
#                    "RM_24h_1", "RM_24h_2", "RM_24h_3",
#                    "CmRM_60.1Counts", "CmRM_60.2Counts", "CmRM_60.3Counts")
# This is a variable for the plotPCA function that lets you subset what you want to look at
#NULL means all columns in this case.
groupsToLookAt = NULL
#Note default this is top 500 most variable genes.
pcaData <- rader_plotPCA(object=rld,
#                         intgroup=c("conditionAndtimepoint"),
intgroup=c(configDesignStr),
returnData=TRUE,
groups=groupsToLookAt,
ntop = 500)
pcaData_FileName = paste(experimentIdentifier, "_PCA.csv", sep="")
write.csv(pcaData, file.path(OutputFileDirectory, pcaData_FileName))
p <- pcaPlotFormated(pcaData,
color=configDesignStr,
legendTitleC = str_to_title(configDesignStr))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier, "_PCA_Plot_rlog.tiff"), sep=""), width=6, height=5,
units = 'in', res = 150)
print(p)
dev.off()
#This code will get the weights for each gene to determine biggset contributers
#To a principal component
pcaResultsGenes <- generateGenePCAValues(rld, groups=groupsToLookAt)
holderDF <- as.data.frame(pcaResultsGenes)
rownames(holderDF) <- rownames(pcaResultsGenes)
genePCAData_name = paste(experimentIdentifier,"_Gene_PCA_Data.csv", sep="")
write.csv(holderDF, file.path(OutputFileDirectory,genePCAData_name))
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_Distance_Plot_rlog_ALL_timepointAsControl.tiff", sep="")), width=575*2, height=575*2, res=200)
#generateDistMatrix(rld, coldata, "conditionAndtimepoint", groups=groupsToLookAt)
generateDistMatrix(rld, coldata, configDesignStr, groups=groupsToLookAt)
dev.off()
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_exploratoryBarPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
generateBarplotForTotalReadCounts(cts, groups=groupsToLookAt)
dev.off()
p <- generateNormalizedBoxplot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryBoxPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
print(p)
dev.off()
p <- generateNormalizedDensityPlot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryDensityPlottemp.tiff", sep="")), width=575*3, height=575*2, res=200)
print(p)
dev.off()
colnames(cts)
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
#________End_PreProcessing__________#
#________Differential Expression Analysis_______#
# control vector and treatedVector should be the same size and be in the order you
# are comparing the to conditions.
# not can do any number of variable combinations.
# Note: The items of this vector should be entries in the column of coldata you are analysizing
#controlVector <- c("RM1h", "RM2h", "RM24h", "RM49h")
#treatedVector <- c("LP1h", "LP2h", "LP24h", "LP49h")
#Moved to metadata file. maybe keep here?
# controlVector <- c("RM")
# treatedVector <- c("Au")
# The variable should be the name of the column in the annotation file that holds
# the terms found in controlVector and treatedVector
#variable <- "conditionAndtimepoint"
variable <- configDesignStr
firstEntry <- TRUE
index <- 1
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
i=1
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
res <- differentialExpression(control, treated, variable, dds, alpha=0.01)
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
head(py_addProteinColumnToDataframe(as.data.frame(res)))
write.csv(apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character)
head(apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character))
fwrite(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
# The variable should be the name of the column in the annotation file that holds
# the terms found in controlVector and treatedVector
#variable <- "conditionAndtimepoint"
variable <- configDesignStr
firstEntry <- TRUE
index <- 1
for(i in 1:length(controlVector)){
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
res <- differentialExpression(control, treated, variable, dds, alpha=0.01)
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(as.data.frame(subset(res, padj < 0.01))), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0p0.01.csv", sep = "")))
#Generate MA plot
py_generateMAPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=.9, comparison = paste(experimentIdentifier,"_", treated, "v", control, sep=""))
py_pvalueVSbasemean(as.data.frame(res), OutputFileDirectory, comparison = paste(experimentIdentifier,"_",treated, "v", control, sep=""), lfc_transform="max")
# this is code that is constructing the a file of all the results.
print(nrow(res))
if(firstEntry){
formatedCSVThereshold0 <- data.frame(matrix(ncol=length(controlVector)*3, nrow =nrow(res) ))
rownames(formatedCSVThereshold0) <- rownames(res)
# formatedCSVThereshold1.99 <- data.frame(matrix(ncol=length(controlVector)*2, nrow =nrow(resLFCThreshold1.99p.01) ))
# rownames(formatedCSVThereshold1.99) <- rownames(resLFCThreshold1.99p.01)
comparison <- c()
thresholdVector <- c()
firstEntry <- FALSE
}
formatedCSVThereshold0 <- combinedResultDataFrames(formatedCSVThereshold0, res, index, control, treated)
index <- index + 3
# per_Index <- getPercentileIndex(res, 0.90)
# print(per_Index)
per_threshold <- getPerThreshold(res, .90, "score")
print(per_threshold)
percentiles = c(.90, .95, .99)
for(per in percentiles){
py_makeHistPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=per, comparison=paste(experimentIdentifier,"_",treated, "v", control, sep=""))
}
# holder <- res[order(res[,"score"]),]
# holder <- holder[complete.cases(holder),]
# head(holder)
# holder[per_Index,"score"]
comparison <- append(comparison, paste(treated, "v", control, sep=""))
thresholdVector <- append(thresholdVector, per_threshold)
thresholdValueHolder <- data.frame(comparison, thresholdVector)
res_ordered <- generateDataframeForVolcanoPlot(res, per_threshold, "LFC", 10)
# print(res_ordered)
scale <- 2.5
p <- generateVolcanoPlot(res_ordered, y_limits = c(0,300), x_limits = c(-7.5,12.5), x_breaks = c(-5,0,5,10,15))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_",treated, "v", control, "_VolcanoPlot.tiff", sep="")),
width = scale*550,
height=scale*500,
res=scale*100)
print(p)
dev.off()
if(i == length(controlVector)){
write.csv(thresholdValueHolder, file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_Comparison_Thresholds.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(formatedCSVThereshold0), file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_AllLFCandPadj_Thereshold0.csv", sep = "")))
}
}
columns = c()
for(e in comparison){
print(e)
columns = append(columns, paste("Score_",e,sep=""))
}
percentiles <- c(.99, .95, .90)
for(per in percentiles){
dist_data = py_densityplotCompareColumns(formatedCSVThereshold0, columns, percentile=per, comparison=str_to_title(configDesignStr), xlabel="score", outputfiledir=OutputFileDirectory, legend=TRUE, expLabel=experimentIdentifier)
}
#____________________Analysis at specific timepoints_____________#
# If time course shows genes are variable over time (or some other variable)
# then good idea to do analysis at each time
source("NewFullRNAseqPipeline_metadata.R")
dds<-DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
# sorts using mincount set in first section
{
keep<-rowSums(DESeq2::counts(dds))>=minimumCount
dds<-dds[keep,]
}
dds <- DESeq(dds)
counts <- DESeq2::counts(dds, normalized = TRUE)
design <- as.data.frame(colData(dds))
rld <- rlog(dds, blind=T)
colData(rld)
# This is a variable for the plotPCA function that lets you subset what you want to look at
#NULL means all columns in this case.
groupsToLookAt = NULL
#Note default this is top 500 most variable genes.
pcaData <- rader_plotPCA(object=rld,
#                         intgroup=c("conditionAndtimepoint"),
intgroup=c(configDesignStr),
returnData=TRUE,
groups=groupsToLookAt,
ntop = 500)
pcaData_FileName = paste(experimentIdentifier, "_PCA.csv", sep="")
write.csv(pcaData, file.path(OutputFileDirectory, pcaData_FileName))
p <- pcaPlotFormated(pcaData,
color=configDesignStr,
legendTitleC = str_to_title(configDesignStr))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier, "_PCA_Plot_rlog.tiff"), sep=""), width=6, height=5,
units = 'in', res = 150)
print(p)
dev.off()
#This code will get the weights for each gene to determine biggset contributers
#To a principal component
pcaResultsGenes <- generateGenePCAValues(rld, groups=groupsToLookAt)
holderDF <- as.data.frame(pcaResultsGenes)
rownames(holderDF) <- rownames(pcaResultsGenes)
genePCAData_name = paste(experimentIdentifier,"_Gene_PCA_Data.csv", sep="")
write.csv(holderDF, file.path(OutputFileDirectory,genePCAData_name))
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_Distance_Plot_rlog_ALL_timepointAsControl.tiff", sep="")), width=575*2, height=575*2, res=200)
#generateDistMatrix(rld, coldata, "conditionAndtimepoint", groups=groupsToLookAt)
generateDistMatrix(rld, coldata, configDesignStr, groups=groupsToLookAt)
dev.off()
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_exploratoryBarPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
generateBarplotForTotalReadCounts(cts, groups=groupsToLookAt)
dev.off()
p <- generateNormalizedBoxplot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryBoxPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
print(p)
dev.off()
p <- generateNormalizedDensityPlot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryDensityPlottemp.tiff", sep="")), width=575*3, height=575*2, res=200)
print(p)
dev.off()
colnames(cts)
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
rlogcounts
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
t
t
t
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
rlogcounts
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}

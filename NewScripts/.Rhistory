#for(i in 1:n){
#  index = as.numeric(i)
#Note you need to have the ordered data "resTSOrdered"
#  geneName <- as.character(rownames(resTSOrdered)[index])
#  p <- countPlotOver2Variables(ddsTimeSeries, geneName, "timepoint", "condition")
#  tiff(paste(OutputFileDirectory, "/", geneName, filename, sep=""), width=12, height=12, res=300)
#  print(p)
#  dev.off()
#}
#____________________END of Time Course analysis_________________#
#____________________Analysis at specific timepoints_____________#
# If time course shows genes are variable over time (or some other variable)
# then good idea to do analysis at each time
source("NewFullRNAseqPipeline_metadata.R")
dds<-DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
# sorts using mincount set in first section
{
keep<-rowSums(DESeq2::counts(dds))>=minimumCount
dds<-dds[keep,]
}
dds <- DESeq(dds)
#_________PreProcessing___________#
counts <- DESeq2::counts(dds, normalized = TRUE)
design <- as.data.frame(colData(dds))
rld <- rlog(dds, blind=T)
colData(rld)
#PCA
# pcaData <- plotPCA(rld, intgroup=c("Groups"), returnData=TRUE)
# rader_plotPCA is the same as plotPCA but allows you to give a paraemeter "groups" That is the list of columns of count data you want to use.
# pcaData <- rader_plotPCA(rld, intgroup=c("Groups"), returnData=TRUE)
# groupsToLookAt = c("CmLS_24.1Counts","CmLS_24.2Counts", "CmLS_24.3Counts",
#                    "CmLS_1.1Counts","CmLS_1.2Counts","CmLS_1.3Counts",
#                    "RM_1h_1","RM_1h_2","RM_1h_3",
#                    "RM_24h_1", "RM_24h_2", "RM_24h_3",
#                    "CmRM_60.1Counts", "CmRM_60.2Counts", "CmRM_60.3Counts")
# This is a variable for the plotPCA function that lets you subset what you want to look at
#NULL means all columns in this case.
groupsToLookAt = NULL
#Note default this is top 500 most variable genes.
pcaData <- rader_plotPCA(object=rld,
#                         intgroup=c("conditionAndtimepoint"),
intgroup=c(configDesignStr),
returnData=TRUE,
groups=groupsToLookAt,
ntop = 500)
pcaData_FileName = paste(experimentIdentifier, "_PCA.csv", sep="")
write.csv(pcaData, file.path(OutputFileDirectory, pcaData_FileName))
p <- pcaPlotFormated(pcaData,
color=configDesignStr,
legendTitleC = str_to_title(configDesignStr))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier, "_PCA_Plot_rlog.tiff"), sep=""), width=6, height=5,
units = 'in', res = 150)
print(p)
dev.off()
#This code will get the weights for each gene to determine biggset contributers
#To a principal component
pcaResultsGenes <- generateGenePCAValues(rld, groups=groupsToLookAt)
holderDF <- as.data.frame(pcaResultsGenes)
rownames(holderDF) <- rownames(pcaResultsGenes)
genePCAData_name = paste(experimentIdentifier,"_Gene_PCA_Data.csv", sep="")
write.csv(holderDF, file.path(OutputFileDirectory,genePCAData_name))
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_Distance_Plot_rlog_ALL_timepointAsControl.tiff", sep="")), width=575*2, height=575*2, res=200)
#generateDistMatrix(rld, coldata, "conditionAndtimepoint", groups=groupsToLookAt)
generateDistMatrix(rld, coldata, configDesignStr, groups=groupsToLookAt)
dev.off()
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_exploratoryBarPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
generateBarplotForTotalReadCounts(cts, groups=groupsToLookAt)
dev.off()
p <- generateNormalizedBoxplot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryBoxPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
print(p)
dev.off()
p <- generateNormalizedDensityPlot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryDensityPlottemp.tiff", sep="")), width=575*3, height=575*2, res=200)
print(p)
dev.off()
colnames(cts)
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
#________End_PreProcessing__________#
#________Differential Expression Analysis_______#
# control vector and treatedVector should be the same size and be in the order you
# are comparing the to conditions.
# not can do any number of variable combinations.
# Note: The items of this vector should be entries in the column of coldata you are analysizing
#controlVector <- c("RM1h", "RM2h", "RM24h", "RM49h")
#treatedVector <- c("LP1h", "LP2h", "LP24h", "LP49h")
#Moved to metadata file. maybe keep here?
# controlVector <- c("RM")
# treatedVector <- c("Au")
# The variable should be the name of the column in the annotation file that holds
# the terms found in controlVector and treatedVector
#variable <- "conditionAndtimepoint"
variable <- configDesignStr
firstEntry <- TRUE
index <- 1
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
i=1
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
res <- differentialExpression(control, treated, variable, dds, alpha=0.01)
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
head(py_addProteinColumnToDataframe(as.data.frame(res)))
write.csv(apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character)
head(apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character))
fwrite(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
# The variable should be the name of the column in the annotation file that holds
# the terms found in controlVector and treatedVector
#variable <- "conditionAndtimepoint"
variable <- configDesignStr
firstEntry <- TRUE
index <- 1
for(i in 1:length(controlVector)){
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
res <- differentialExpression(control, treated, variable, dds, alpha=0.01)
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(as.data.frame(subset(res, padj < 0.01))), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0p0.01.csv", sep = "")))
#Generate MA plot
py_generateMAPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=.9, comparison = paste(experimentIdentifier,"_", treated, "v", control, sep=""))
py_pvalueVSbasemean(as.data.frame(res), OutputFileDirectory, comparison = paste(experimentIdentifier,"_",treated, "v", control, sep=""), lfc_transform="max")
# this is code that is constructing the a file of all the results.
print(nrow(res))
if(firstEntry){
formatedCSVThereshold0 <- data.frame(matrix(ncol=length(controlVector)*3, nrow =nrow(res) ))
rownames(formatedCSVThereshold0) <- rownames(res)
# formatedCSVThereshold1.99 <- data.frame(matrix(ncol=length(controlVector)*2, nrow =nrow(resLFCThreshold1.99p.01) ))
# rownames(formatedCSVThereshold1.99) <- rownames(resLFCThreshold1.99p.01)
comparison <- c()
thresholdVector <- c()
firstEntry <- FALSE
}
formatedCSVThereshold0 <- combinedResultDataFrames(formatedCSVThereshold0, res, index, control, treated)
index <- index + 3
# per_Index <- getPercentileIndex(res, 0.90)
# print(per_Index)
per_threshold <- getPerThreshold(res, .90, "score")
print(per_threshold)
percentiles = c(.90, .95, .99)
for(per in percentiles){
py_makeHistPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=per, comparison=paste(experimentIdentifier,"_",treated, "v", control, sep=""))
}
# holder <- res[order(res[,"score"]),]
# holder <- holder[complete.cases(holder),]
# head(holder)
# holder[per_Index,"score"]
comparison <- append(comparison, paste(treated, "v", control, sep=""))
thresholdVector <- append(thresholdVector, per_threshold)
thresholdValueHolder <- data.frame(comparison, thresholdVector)
res_ordered <- generateDataframeForVolcanoPlot(res, per_threshold, "LFC", 10)
# print(res_ordered)
scale <- 2.5
p <- generateVolcanoPlot(res_ordered, y_limits = c(0,300), x_limits = c(-7.5,12.5), x_breaks = c(-5,0,5,10,15))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_",treated, "v", control, "_VolcanoPlot.tiff", sep="")),
width = scale*550,
height=scale*500,
res=scale*100)
print(p)
dev.off()
if(i == length(controlVector)){
write.csv(thresholdValueHolder, file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_Comparison_Thresholds.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(formatedCSVThereshold0), file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_AllLFCandPadj_Thereshold0.csv", sep = "")))
}
}
columns = c()
for(e in comparison){
print(e)
columns = append(columns, paste("Score_",e,sep=""))
}
percentiles <- c(.99, .95, .90)
for(per in percentiles){
dist_data = py_densityplotCompareColumns(formatedCSVThereshold0, columns, percentile=per, comparison=str_to_title(configDesignStr), xlabel="score", outputfiledir=OutputFileDirectory, legend=TRUE, expLabel=experimentIdentifier)
}
#____________________Analysis at specific timepoints_____________#
# If time course shows genes are variable over time (or some other variable)
# then good idea to do analysis at each time
source("NewFullRNAseqPipeline_metadata.R")
dds<-DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
# sorts using mincount set in first section
{
keep<-rowSums(DESeq2::counts(dds))>=minimumCount
dds<-dds[keep,]
}
dds <- DESeq(dds)
counts <- DESeq2::counts(dds, normalized = TRUE)
design <- as.data.frame(colData(dds))
rld <- rlog(dds, blind=T)
colData(rld)
# This is a variable for the plotPCA function that lets you subset what you want to look at
#NULL means all columns in this case.
groupsToLookAt = NULL
#Note default this is top 500 most variable genes.
pcaData <- rader_plotPCA(object=rld,
#                         intgroup=c("conditionAndtimepoint"),
intgroup=c(configDesignStr),
returnData=TRUE,
groups=groupsToLookAt,
ntop = 500)
pcaData_FileName = paste(experimentIdentifier, "_PCA.csv", sep="")
write.csv(pcaData, file.path(OutputFileDirectory, pcaData_FileName))
p <- pcaPlotFormated(pcaData,
color=configDesignStr,
legendTitleC = str_to_title(configDesignStr))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier, "_PCA_Plot_rlog.tiff"), sep=""), width=6, height=5,
units = 'in', res = 150)
print(p)
dev.off()
#This code will get the weights for each gene to determine biggset contributers
#To a principal component
pcaResultsGenes <- generateGenePCAValues(rld, groups=groupsToLookAt)
holderDF <- as.data.frame(pcaResultsGenes)
rownames(holderDF) <- rownames(pcaResultsGenes)
genePCAData_name = paste(experimentIdentifier,"_Gene_PCA_Data.csv", sep="")
write.csv(holderDF, file.path(OutputFileDirectory,genePCAData_name))
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_Distance_Plot_rlog_ALL_timepointAsControl.tiff", sep="")), width=575*2, height=575*2, res=200)
#generateDistMatrix(rld, coldata, "conditionAndtimepoint", groups=groupsToLookAt)
generateDistMatrix(rld, coldata, configDesignStr, groups=groupsToLookAt)
dev.off()
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_exploratoryBarPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
generateBarplotForTotalReadCounts(cts, groups=groupsToLookAt)
dev.off()
p <- generateNormalizedBoxplot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryBoxPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
print(p)
dev.off()
p <- generateNormalizedDensityPlot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryDensityPlottemp.tiff", sep="")), width=575*3, height=575*2, res=200)
print(p)
dev.off()
colnames(cts)
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
rlogcounts
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
t
t
t
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
rlogcounts
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
#____________________Analysis at specific timepoints_____________#
# If time course shows genes are variable over time (or some other variable)
# then good idea to do analysis at each time
source("NewFullRNAseqPipeline_metadata.R")
dds<-DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
dds<-DESeq2::DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("R_initialize_metadata.R")
source("DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
pythonInstanceDir
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("NewScripts\\R_initialize_metadata.R")
source("NewScripts\\DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("NewScripts\\R_initialize_metadata.R")
source("NewScripts\\DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("NewScripts\\R_initialize_metadata.R")
source("NewScripts\\DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("NewScripts\\R_initialize_metadata.R")
source("NewScripts\\DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("NewScripts\\R_initialize_metadata.R")
source("NewScripts\\DifferentialExpressionFunctions.R")
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("NewScripts\\R_initialize_metadata.R")
# Chosen Working Directory (Default is current working directory.)
workingDirectory = "C:\\Users\\dfoss\\Documents\\Projects\\RaderLab\\RaderLabCode\\NewScripts"
setwd(workingDirectory)
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("R_initialize_metadata.R")
source("DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
cwd()
getcwd()
getwd()
pythonModuleDir
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}

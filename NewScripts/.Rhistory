print(control)
treated <- treatedVector[i]
print(treated)
i=1
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
res <- differentialExpression(control, treated, variable, dds, alpha=0.01)
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
head(py_addProteinColumnToDataframe(as.data.frame(res)))
write.csv(apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character)
head(apply(py_addProteinColumnToDataframe(as.data.frame(res)),1,as.character))
fwrite(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
#Setting up python instance
#cmd- which python3 gets path
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
# The variable should be the name of the column in the annotation file that holds
# the terms found in controlVector and treatedVector
#variable <- "conditionAndtimepoint"
variable <- configDesignStr
firstEntry <- TRUE
index <- 1
for(i in 1:length(controlVector)){
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
res <- differentialExpression(control, treated, variable, dds, alpha=0.01)
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(as.data.frame(subset(res, padj < 0.01))), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0p0.01.csv", sep = "")))
#Generate MA plot
py_generateMAPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=.9, comparison = paste(experimentIdentifier,"_", treated, "v", control, sep=""))
py_pvalueVSbasemean(as.data.frame(res), OutputFileDirectory, comparison = paste(experimentIdentifier,"_",treated, "v", control, sep=""), lfc_transform="max")
# this is code that is constructing the a file of all the results.
print(nrow(res))
if(firstEntry){
formatedCSVThereshold0 <- data.frame(matrix(ncol=length(controlVector)*3, nrow =nrow(res) ))
rownames(formatedCSVThereshold0) <- rownames(res)
# formatedCSVThereshold1.99 <- data.frame(matrix(ncol=length(controlVector)*2, nrow =nrow(resLFCThreshold1.99p.01) ))
# rownames(formatedCSVThereshold1.99) <- rownames(resLFCThreshold1.99p.01)
comparison <- c()
thresholdVector <- c()
firstEntry <- FALSE
}
formatedCSVThereshold0 <- combinedResultDataFrames(formatedCSVThereshold0, res, index, control, treated)
index <- index + 3
# per_Index <- getPercentileIndex(res, 0.90)
# print(per_Index)
per_threshold <- getPerThreshold(res, .90, "score")
print(per_threshold)
percentiles = c(.90, .95, .99)
for(per in percentiles){
py_makeHistPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=per, comparison=paste(experimentIdentifier,"_",treated, "v", control, sep=""))
}
# holder <- res[order(res[,"score"]),]
# holder <- holder[complete.cases(holder),]
# head(holder)
# holder[per_Index,"score"]
comparison <- append(comparison, paste(treated, "v", control, sep=""))
thresholdVector <- append(thresholdVector, per_threshold)
thresholdValueHolder <- data.frame(comparison, thresholdVector)
res_ordered <- generateDataframeForVolcanoPlot(res, per_threshold, "LFC", 10)
# print(res_ordered)
scale <- 2.5
p <- generateVolcanoPlot(res_ordered, y_limits = c(0,300), x_limits = c(-7.5,12.5), x_breaks = c(-5,0,5,10,15))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_",treated, "v", control, "_VolcanoPlot.tiff", sep="")),
width = scale*550,
height=scale*500,
res=scale*100)
print(p)
dev.off()
if(i == length(controlVector)){
write.csv(thresholdValueHolder, file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_Comparison_Thresholds.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(formatedCSVThereshold0), file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_AllLFCandPadj_Thereshold0.csv", sep = "")))
}
}
columns = c()
for(e in comparison){
print(e)
columns = append(columns, paste("Score_",e,sep=""))
}
percentiles <- c(.99, .95, .90)
for(per in percentiles){
dist_data = py_densityplotCompareColumns(formatedCSVThereshold0, columns, percentile=per, comparison=str_to_title(configDesignStr), xlabel="score", outputfiledir=OutputFileDirectory, legend=TRUE, expLabel=experimentIdentifier)
}
#____________________Analysis at specific timepoints_____________#
# If time course shows genes are variable over time (or some other variable)
# then good idea to do analysis at each time
source("NewFullRNAseqPipeline_metadata.R")
dds<-DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
# sorts using mincount set in first section
{
keep<-rowSums(DESeq2::counts(dds))>=minimumCount
dds<-dds[keep,]
}
dds <- DESeq(dds)
counts <- DESeq2::counts(dds, normalized = TRUE)
design <- as.data.frame(colData(dds))
rld <- rlog(dds, blind=T)
colData(rld)
# This is a variable for the plotPCA function that lets you subset what you want to look at
#NULL means all columns in this case.
groupsToLookAt = NULL
#Note default this is top 500 most variable genes.
pcaData <- rader_plotPCA(object=rld,
#                         intgroup=c("conditionAndtimepoint"),
intgroup=c(configDesignStr),
returnData=TRUE,
groups=groupsToLookAt,
ntop = 500)
pcaData_FileName = paste(experimentIdentifier, "_PCA.csv", sep="")
write.csv(pcaData, file.path(OutputFileDirectory, pcaData_FileName))
p <- pcaPlotFormated(pcaData,
color=configDesignStr,
legendTitleC = str_to_title(configDesignStr))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier, "_PCA_Plot_rlog.tiff"), sep=""), width=6, height=5,
units = 'in', res = 150)
print(p)
dev.off()
#This code will get the weights for each gene to determine biggset contributers
#To a principal component
pcaResultsGenes <- generateGenePCAValues(rld, groups=groupsToLookAt)
holderDF <- as.data.frame(pcaResultsGenes)
rownames(holderDF) <- rownames(pcaResultsGenes)
genePCAData_name = paste(experimentIdentifier,"_Gene_PCA_Data.csv", sep="")
write.csv(holderDF, file.path(OutputFileDirectory,genePCAData_name))
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_Distance_Plot_rlog_ALL_timepointAsControl.tiff", sep="")), width=575*2, height=575*2, res=200)
#generateDistMatrix(rld, coldata, "conditionAndtimepoint", groups=groupsToLookAt)
generateDistMatrix(rld, coldata, configDesignStr, groups=groupsToLookAt)
dev.off()
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_exploratoryBarPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
generateBarplotForTotalReadCounts(cts, groups=groupsToLookAt)
dev.off()
p <- generateNormalizedBoxplot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryBoxPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
print(p)
dev.off()
p <- generateNormalizedDensityPlot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryDensityPlottemp.tiff", sep="")), width=575*3, height=575*2, res=200)
print(p)
dev.off()
colnames(cts)
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
rlogcounts
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
t
t
t
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
rlogcounts
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
source("DifferentialExpressionFunctions.R")
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
# Working Directory (Default is current working directory.)
workingDirectory = "C:\\Users\\dfoss\\Documents\\Projects\\RaderLab\\RaderLabCode\\NewScripts"
setwd(workingDirectory)
# This loads all the function from the DifferentialExpressionFunctions.R script. Make sure its the right directory for you
source("R_initialize_metadata.R")
source("DifferentialExpressionFunctions.R")
set.seed(123)
#Setting up python instance
#cmd- which python3 gets path
# python working directory is not R working directory but is the directory RStudio is opened in
# lame
{
use_python(pythonInstanceDir, required = T)
py_config()
source_python(pythonModuleDir)
}
# This location is where ouput Files will Start. Should be name of folder in working directory
OutputFileDirectory <- file.path(workingDirectory, outputDirName)
# Location of data
# This is usually in the working directory but doesn't have to be.
#Keep all data in one directory and padting the specific directory here
# can be useful for not having duplicates
CountFileDirectory <- CountFileDirectory
# AnnotationFileDirectory <- "/Users/dfossl/OneDrive/Documents/Dylan_School_Cloud/Rader Lab/Analysis-LP/Deseq2Analysis_LowPhosphorous/LP_annotation.csv"
AnnotationFileDirectory <- AnnotationFileDirectory
cts <- read.csv(CountFileDirectory, row.names=1)
coldata <- read.csv(AnnotationFileDirectory, row.names=1)
coldata <- droplevels(coldata)
#Makes sure the columns in data match rows in annotation.
checkColumnsMatch(coldata, cts)
rownames(coldata) %in% colnames(cts)
if(!checkColumnsMatch(coldata, cts)){
print("ERROR, you have rows and columns with different names or exrta rows or columns.
Therefore reformat Data till TRUE. ")
}
#expVariables holds list of variable conditions
expvariables <- colnames(coldata)
expvariables
# Set what the minimum count you wish each row to sum too.
# Deseq2 Documentation claims more robust filtering in making the Deseq object
# So I am trusting them on this,
minimumCount <- 10
#____________________Analysis at specific timepoints_____________#
# If time course shows genes are variable over time (or some other variable)
# then good idea to do analysis at each time
source("NewFullRNAseqPipeline_metadata.R")
dds<-DESeqDataSetFromMatrix( countData = cts,
colData = coldata,
design = configDesign)
# sorts using mincount set in first section
{
keep<-rowSums(DESeq2::counts(dds))>=minimumCount
dds<-dds[keep,]
}
dds <- DESeq(dds)
counts <- DESeq2::counts(dds, normalized = TRUE)
design <- as.data.frame(colData(dds))
rld <- rlog(dds, blind=T)
colData(rld)
# This is a variable for the plotPCA function that lets you subset what you want to look at
#NULL means all columns in this case.
groupsToLookAt = NULL
#Note default this is top 500 most variable genes.
pcaData <- rader_plotPCA(object=rld,
#                         intgroup=c("conditionAndtimepoint"),
intgroup=c(configDesignStr),
returnData=TRUE,
groups=groupsToLookAt,
ntop = 500)
pcaData_FileName = paste(experimentIdentifier, "_PCA.csv", sep="")
write.csv(pcaData, file.path(OutputFileDirectory, pcaData_FileName))
p <- pcaPlotFormated(pcaData,
color=configDesignStr,
legendTitleC = str_to_title(configDesignStr))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier, "_PCA_Plot_rlog.tiff"), sep=""), width=6, height=5,
units = 'in', res = 150)
print(p)
dev.off()
#This code will get the weights for each gene to determine biggset contributers
#To a principal component
pcaResultsGenes <- generateGenePCAValues(rld, groups=groupsToLookAt)
holderDF <- as.data.frame(pcaResultsGenes)
rownames(holderDF) <- rownames(pcaResultsGenes)
genePCAData_name = paste(experimentIdentifier,"_Gene_PCA_Data.csv", sep="")
write.csv(holderDF, file.path(OutputFileDirectory,genePCAData_name))
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_Distance_Plot_rlog_ALL_timepointAsControl.tiff", sep="")), width=575*2, height=575*2, res=200)
#generateDistMatrix(rld, coldata, "conditionAndtimepoint", groups=groupsToLookAt)
generateDistMatrix(rld, coldata, configDesignStr, groups=groupsToLookAt)
dev.off()
tiff(file.path(OutputFileDirectory, paste(experimentIdentifier,"_exploratoryBarPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
generateBarplotForTotalReadCounts(cts, groups=groupsToLookAt)
dev.off()
p <- generateNormalizedBoxplot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryBoxPlottemp.tiff", sep="")), width=575*2, height=575*2, res=200)
print(p)
dev.off()
p <- generateNormalizedDensityPlot(cts, groups=groupsToLookAt)
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_exploratoryDensityPlottemp.tiff", sep="")), width=575*3, height=575*2, res=200)
print(p)
dev.off()
colnames(cts)
rlogcounts <- generaterlogNormalizedCountDataFrame(cts, groups=groupsToLookAt)
coldata_filtered <- rowFilter(coldata, groups=groupsToLookAt)
coldata_filtered
numberOfGenes <- c(10,100,500,1000)
for(geneNumber in numberOfGenes){
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_Z-Score.HeatMap", geneNumber, "MostVariableGenes_ALL.tiff", sep="")),
width = 5,
height = 6,
units='in',
res=250)
if(geneNumber < 100){
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber)
}else{
generateGeneCountVarianceHeatmap(rlogcounts, coldata_filtered, configDesignStr, geneNumber, labRow = FALSE)
}
dev.off()
}
# The variable should be the name of the column in the annotation file that holds
# the terms found in controlVector and treatedVector
#variable <- "conditionAndtimepoint"
variable <- configDesignStr
firstEntry <- TRUE
index <- 1
for(i in 1:length(controlVector)){
control <- controlVector[i]
print(control)
treated <- treatedVector[i]
print(treated)
res <- differentialExpression(control, treated, variable, dds, alpha=0.01)
write.csv(py_addProteinColumnToDataframe(as.data.frame(res)), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(as.data.frame(subset(res, padj < 0.01))), file = file.path(OutputFileDirectory, paste(experimentIdentifier,"_",treated, "v", control,"_DESeq2ResultsThreshold0p0.01.csv", sep = "")))
#Generate MA plot
py_generateMAPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=.9, comparison = paste(experimentIdentifier,"_", treated, "v", control, sep=""))
py_pvalueVSbasemean(as.data.frame(res), OutputFileDirectory, comparison = paste(experimentIdentifier,"_",treated, "v", control, sep=""), lfc_transform="max")
# this is code that is constructing the a file of all the results.
print(nrow(res))
if(firstEntry){
formatedCSVThereshold0 <- data.frame(matrix(ncol=length(controlVector)*3, nrow =nrow(res) ))
rownames(formatedCSVThereshold0) <- rownames(res)
# formatedCSVThereshold1.99 <- data.frame(matrix(ncol=length(controlVector)*2, nrow =nrow(resLFCThreshold1.99p.01) ))
# rownames(formatedCSVThereshold1.99) <- rownames(resLFCThreshold1.99p.01)
comparison <- c()
thresholdVector <- c()
firstEntry <- FALSE
}
formatedCSVThereshold0 <- combinedResultDataFrames(formatedCSVThereshold0, res, index, control, treated)
index <- index + 3
# per_Index <- getPercentileIndex(res, 0.90)
# print(per_Index)
per_threshold <- getPerThreshold(res, .90, "score")
print(per_threshold)
percentiles = c(.90, .95, .99)
for(per in percentiles){
py_makeHistPlot(as.data.frame(res), OutputFileDirectory, "score", percentile=per, comparison=paste(experimentIdentifier,"_",treated, "v", control, sep=""))
}
# holder <- res[order(res[,"score"]),]
# holder <- holder[complete.cases(holder),]
# head(holder)
# holder[per_Index,"score"]
comparison <- append(comparison, paste(treated, "v", control, sep=""))
thresholdVector <- append(thresholdVector, per_threshold)
thresholdValueHolder <- data.frame(comparison, thresholdVector)
res_ordered <- generateDataframeForVolcanoPlot(res, per_threshold, "LFC", 10)
# print(res_ordered)
scale <- 2.5
p <- generateVolcanoPlot(res_ordered, y_limits = c(0,300), x_limits = c(-7.5,12.5), x_breaks = c(-5,0,5,10,15))
tiff(file.path(OutputFileDirectory,paste(experimentIdentifier,"_",treated, "v", control, "_VolcanoPlot.tiff", sep="")),
width = scale*550,
height=scale*500,
res=scale*100)
print(p)
dev.off()
if(i == length(controlVector)){
write.csv(thresholdValueHolder, file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_Comparison_Thresholds.csv", sep = "")))
write.csv(py_addProteinColumnToDataframe(formatedCSVThereshold0), file = file.path(OutputFileDirectory,paste(experimentIdentifier,"_AllLFCandPadj_Thereshold0.csv", sep = "")))
}
}
columns = c()
for(e in comparison){
print(e)
columns = append(columns, paste("Score_",e,sep=""))
}
percentiles <- c(.99, .95, .90)
for(per in percentiles){
dist_data = py_densityplotCompareColumns(formatedCSVThereshold0, columns, percentile=per, comparison=str_to_title(configDesignStr), xlabel="score", outputfiledir=OutputFileDirectory, legend=TRUE, expLabel=experimentIdentifier)
}
#__________Python Enrichment_________#
percentiles <- c(.99, .95, .90)
test <- keggEnrichmentOnPercentiles(formatedCSVThereshold0, percentiles, metric="score", outputDir=OutputFileDirectory)
test[0:2]
pathways <- py_GetAllPathwaysOfSig(test[0:6], p_cutoff=0.05)
keggDataFrame <- py_getKEGGDataframe(formatedCSVThereshold0)
colnames(keggDataFrame)
kegg_LFC <- keggDataFrame[,c("LFC_LP1hvRM1h", "LFC_LP2hvRM2h", "LFC_LP24hvRM24h", "LFC_LP49hvRM49h")]
#Flip sign so that legend shows green as positive and red negative.
# org_kegg_LFC <- kegg_LFC
kegg_LFC <- -1*kegg_LFC
kegg_LFC <- keggDataFrame[,c("LFC_LP1hvRM1h", "LFC_LP2hvRM2h", "LFC_LP24hvRM24h", "LFC_LP49hvRM49h")]
kegg_LFC <- keggDataFrame[,c("LFC_LP1hvRM1h", "LFC_LP2hvRM2h", "LFC_LP24hvRM24h", "LFC_LP49hvRM49h")]
# gene.data must have gene ids as the index. IF it doesn't it will not color properly.
pv.out.list <- sapply(pathways, function(pid) pathview(gene.data = kegg_LFC, pathway.id = pid, species = "cme", gene.idtype = "KEGG",plot.col.key=R,
low = list(gene = "red", cpd ="yellow"),
mid = list(gene = "gray", cpd = "gray"),
high = list(gene = "green", cpd = "blue")))
# gene.data must have gene ids as the index. IF it doesn't it will not color properly.
pv.out.list <- sapply(pathways, function(pid) pathview(gene.data = kegg_LFC, pathway.id = pid, species = "cme", gene.idtype = "KEGG",plot.col.key=TRUE,
low = list(gene = "red", cpd ="yellow"),
mid = list(gene = "gray", cpd = "gray"),
high = list(gene = "green", cpd = "blue")))
